# 编码

本文档描述了 protocol buffer 消息的二进制格式。在程序中使用 protocol buffers 时不需要理解这些内容，但是了解不同 protocol buffer 格式对编码消息大小的影响是非常有用的。

## 简单消息

假设有如下一个非常简单的消息定义：

``` protobuf
message Test1 {
    optional int32 a = 1;
}
```

在程序中，创建一个 Test1 的对象并设置 a 的值为 150。然后将此对象序列化到输出流。检查编码消息，将看到三个字节：

```
0x08 0x96 0x01
```

到此为止，非常小的字节数组。但是它表示什么呢？继续阅读……

## 基本 128 varints

要理解上面简单的 protocol buffer 编码，首先需要理解 varints。 varints 是使用一个或多个字节序列化整数的方法。越小的数字需要的字节数越少。

一个 varint 中除最后一个字节外的每个字节都设置了最高有效位（MSB），表示后面还有更多的字节。每个字节的低 7 位采用低位数据在前的方式存储数字补码按 7 位分组的数据

因此，对于单字节的数字 1，不需要设置 MSB：

```
00000001
```

对于数字 300，会变得有一点复杂：

```
10101100 00000010
```

如何从以上数据解析出数字 300呢？首先移除每个字节的 MSB，因为它仅仅表示数据是否结束（可以看到，在 varint 中的第一个字节中设置了 MSB，因为后面还有更多字节）：

```
  10101100 00000010
→  0101100  0000010
```

反转两组 7 位数据，如上面所说，varints 采用低位数据在前的形式存储数字。之后将它们连接起来就得到了最终结果：

```
  0101100 0000010
→ 0000010 0101100
→ 1 00101100
→ 256 + 32 + 8 + 4 = 300
```

## 消息结构

我们已经知道，一个 protocol buffer 消息是一系列的键值对。一个消息的二进制版本仅使用字段号作为键值， 每个字段的名称和声明类型只能在解码结束时通过引用消息类型定义（如 .proto 文件）来确定。

消息编码后，键和值连接成一个字节流。消息解码后，解析器需要具有跳过无法识别的字段的功能，这样，可以向消息中加入新字段而不中断那些不识别它们的老程序。为此，消息中的每个键值对的键值实际上是两个值：.proto 文件中的字段号和一个仅提供确定后面值长度信息的封装类型（wire type）。在大多数语言的实现中，这个键值被称为标记（TAG）。

可用的封装类型如下所示：

|类型|含义|用于|
|-|-|-|
|0|Varint|int32, int64, uint32, uint64, bool, enum|
|1|64-bit|fixed64, sfixed64, double|
|2|Length-delimited|string, bytes, embedded messages, packed repeated fields|
|3|start group| groups(已过时)|
|4|end group| groups(已过时)|
|5|32-bit|fixed32, sfixed32, float|

信息流中的每个键值是一个 varint，值为 `(field_number << 3) | (wire_type)`，换句话说，键值的最后三位存储了封装类型。

现在回到最开始的简单例子。我们现在知道流中的第一个数字一定是一个 varint 键值，这里是 0x08， 或者（移除 MSB）：

```
0001000
```

取出最后三位得到封装类型（0）之后右移三位得到字段号（1）。因此现在知道了字段号为 1 并且接下来的值是一个 varint。

利用上一部分介绍的有关 varint 解码的知识，可以解析出下面两个字节存储的值为 150。

```
0x96 0x01 = 10010110 00000001
          →  0000001  0010110
          → 10010110
          → 128 + 16 + 4 + 2 = 150 
```

## 更多的值类型

### 有符号整数

正如上一部分所介绍的那样，所有封装类型为 0 的 protocol buffer 类型都被编码为 varints。但是，在有符号整数类型（`sint32` 和 `sint64`）与标准整数类型（`int32` 和 `int64`）编码负数的时候有一个重要的区别。如果使用 `int32` 或 `int64` 作为负数的类型， varint 结果的长度总是 10 字节，实际上，它被视为一个非常大的无符号整数。如果你使用有符号整数类型，varint 结果会使用效率更高的 ZigZag 编码。

ZigZag 编码映射有符号整数到无符号整数，这样对于绝对值很小的数字（例如 -1）也可以编码为一个小的 varint。它通过一种往返与正数和负数间的 “之字形” 方式来达到这个目的，这样 -1 被编码为 1，1 被编码为 2，-2 被编码为 3，以此类推，如下表所示：

|原始值|编码值|
|-|-|
|0|0|
|-1|1|
|1|2|
|-2|3|
|2147483647|4294967294|
|-2147483648|4294967295|

换句话说，每个值 n 使用如下算法进行编码：

对于 `sint32`：

```
(n << 1) ^ (n >> 31)
```

对于 `sint64`：

```
(n << 1) ^ (n >> 63)
```

注意第二个移位操作`（n >> 31）`是算术移位。换句话说，移位的结果是一个比特位要么全为 0（当 n 为正数时）要么全为 1（当 n 为负数时）的数字。

当解析 `sint32` 或 `sint64` 时，会被解码回原始的有符号版本。

### 非 varint 数字

非 varint 数值类型很简单，double 和 fixed64 的封装类型为 1，它告诉解析器需要一个固定的 64 位数据区域；类似地，float 和 fixed32 的封装类型为 5，它告诉解析器需要 32 位数据区域。两种情况下，值都是以小端法存储的。

### 字符串

固定类型为 2（length-delimited）表示该值是一个编码长度后面跟指定字节长度数据的 varint。

``` protobuf
message Test2 {
  optional string b = 2;
}
```

设置 b 的值为 “testing” 会得到：

```
0x12 0x07 0x74 0x65 0x73 0x74 0x69 0x6e 0x67
```

这里的键值是 0x12，解析后得到：

```
  0x12
→ 00010010  (二进制格式)
→ 00010 010 (按位重新分组)
→ field_number = 2, wire_type = 2
```

varint 的长度为 7，向后取 7 个字节，得到 “testing” 以 UTF8 编码后的字节数组

### 嵌套消息

下面是一个包含示例类型 Test1 的嵌套消息的消息定义：

``` protobuf
message Test3 {
  optional Test1 c = 3;
}
```

下面是它编码后的版本，这里再次把 Test1 的 a 字段设置为 150：

```
0x1a 0x03 0x08 0x96 0x01
```

可以看出，最后三个字节与之前的示例（0x08 0x96 0x01）完全相同，前面代表嵌入消息的字段号 3 和封装类型 2 的处理方式与字符串的处理方式完全相同。

### 可选和重复元素

如果在 proto2 的消息定义中存在重复元素（没有 [packed=true] 选项），则编码消息有 0 个或多个具有相同字段号的键值对。这些重复的值不必连续出现；它们可以与其他字段交叉出现。在解析时，尽管相对于其他字段的顺序会丢失，但是元素间的顺序会保持不变。在 proto3 中，重复字段使用压缩编码，相关内容会在下面提到。

对于 proto3 中的任何非重复字段，或 proto2 中的可选字段，编码消息可能有或没有该字段对应的键值对。

通常情况下，一个编码消息不会有一个以上的非重复字段实例。但是，解析器需要这种情况。对于数值和字符串类型，如果同一个字段多次出现，解析器接受最后一个值。对于嵌套的消息字段，解析器合并同一字段的多个实例，就像使用 Message::MergeFrom 方法一样，也就是说，后一个实例中的标量字段将替换掉前一个实例中的对应字段，合并嵌套消息，并连接重复字段。这些规则的效果是，解析两个串联的编码消息会产生与单独解析两个消息然后合并对象一样的结果。也就是说：

```
MyMessage message;
message.ParseFromString(str1 + str2);
```

等效于

```
MyMessage message, message2;
message.ParseFromString(str1);
message2.ParseFromString(str2);
message.MergeFrom(message2);
```
此属性有时候会很有用，因为这将允许我们合并两条消息即使我们不知道它们的类型。

### 打包重复字段

2.1.0 版本引入了打包重复字段的机制，在 proto2 中这些字段被声明为带有 [packed = true] 选项的重复字段。在 proto3 中，标准数值类型的重复字段默认将被打包。这项功能类似于重复字段，但是编码方式不同。不含元素的打包重复字段不会出现在编码消息中。否则，字段的所有元素将被打包到一个具有封装类型为 2（length-delimited）的键值对中。每个元素的编码方式不变，但是前面不再包括键值。

例如，假设有下面的消息类型：

``` protobuf
message Test4 {
  repeated int32 d = 4 [packed = true];
}
```

现在假设我们构造了一个 Test4 对象，为重复字段提供的值为 3，270 和 86942。那么它的编码形式将是：

```
0x22            // 键值（字段号 4，封装类型 2）
0x06            // 数据长度（6 字节）
0x03            // 第一个元素（varint 3）
0x8e 0x02       // 第二个元素（varint 270）
0x9e 0xa7 0x05  // 第三个元素（varint 86942）
```

只有原始数值类型（使用 varint, 32 位或 64 位封装类型的类型）的重复字段才能被声明为 `packed`。

注意，尽管通常不会将压缩的重复字段编码位多个键值对，单编码器必须能够接受多个键值对。在这种情况下，需要连接数据。每个键值对必须包含完整的元素个数。

Protocol Buffer 解析器必须能够以没有被打包的方式解析被编译为打包的重复字段，反之亦然。这允许以向前向后兼容的方式向现有字段添加 [packed = true]。

### 字段顺序

在 .proto 文件中字段号可以以任何顺序使用。所选顺序对于消息序列化没有任何影响。

当消息被序列化时，它的已知或未知字段写入的顺序不能得到保证。序列化顺序时一个实现细节，任何特定的实现细节在将来都可能改变。因此，protocol buffer 解析器必须能够以任何顺序解析字段。

#### 影响

- 不要假定序列化消息的字节输出是稳定的。尤其是对于那些具有传递其他 protocol buffer 消息字节的字段的消息来说。
- 默认情况下，对于同一个 protocol buffer 消息实例重复调用序列化方法可能不会返回相同的字节输入。也就是说，默认序列化是不确定的。
  - 确定性序列化只保证对于特定二进制具有相同字节输出。对于不同版本的二进制数据，字节输出可能会发生变化。
- 下列对于 protocol buffer 消息实例 `foo` 的检查可能会失败。
  - `foo.SerializeAsString() == foo.SerializeAsString()`
  - `Hash(foo.SerializeAsString()) == Hash(foo.SerializeAsString())`
  - `CRC(foo.SerializeAsString()) == CRC(foo.SerializeAsString())`
  - `FingerPrint(foo.SerializeAsString()) == FingerPrint(foo.SerializeAsString())`
- 下面是一些示例场景，对于逻辑上等价的 protocol buffer 消息 `foo` 和 `bar` 可能会序列化位不同的字节输出。
  - `bar` 由一个旧的服务器序列化，该服务器将某些字段视为未知字段。
  - `bar` 由一个使用不同编程语言的服务器序列化，字段以不同顺序进行序列化。
  - `bar` 具有一个不确定序列化方式的字段。
  - `bar` 具有一个存储不同序列化方式的 protocol buffer 消息字节输出的字段。
  - `bar` 由一个新服务器序列化，由于实现改变，导致服务器以不同顺序序列化字段。
  - `foo` 和 `bar` 都是单独消息的串联，但是顺序不同。