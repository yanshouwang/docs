# 编码

本文档描述了 protocol buffer 消息的二进制格式。在程序中使用 protocol buffers 时不需要理解这些内容，但是了解不同 protocol buffer 格式对编码消息大小的影响是非常有用的。

## 简单消息

假设有如下一个非常简单的消息定义：

```
message Test1 {
    optional int32 a = 1;
}
```

在程序中，创建一个 Test1 的对象并设置 a 的值为 150。然后将此对象序列化到输出流。检查编码消息，将看到三个字节：

```
0x08 0x96 0x01
```

到此为止，非常小的字节数组。但是它表示什么呢？继续阅读……

## 基本 128 varints

要理解上面简单的 protocol buffer 编码，首先需要理解 varints。 varints 是使用一个或多个字节序列化整数的方法。越小的数字需要的字节数越少。

一个 varint 中除最后一个字节外的每个字节都设置了最高有效位（MSB），表示后面还有更多的字节。每个字节的低 7 位采用低位数据在前的方式存储数字补码按 7 位分组的数据

因此，对于单字节的数字 1，不需要设置 MSB：

```
00000001
```

对于数字 300，会变得有一点复杂：

```
10101100 00000010
```

如何从以上数据解析出数字 300呢？首先移除每个字节的 MSB，因为它仅仅表示数据是否结束（可以看到，在 varint 中的第一个字节中设置了 MSB，因为后面还有更多字节）：

```
  10101100 00000010
→  0101100  0000010
```

反转两组 7 位数据，如上面所说，varints 采用低位数据在前的形式存储数字。之后将它们连接起来就得到了最终结果：

```
  0101100 0000010
→ 0000010 0101100
→ 1 00101100
→ 256 + 32 + 8 + 4 = 300
```

## 消息结构

我们已经知道，一个 protocol buffer 消息是一系列的键值对。一个消息的二进制版本仅使用字段的数字作为键值， 每个字段的名称和声明类型只能在解码结束时通过引用消息类型定义（如 .proto 文件）来确定。

消息编码后，键和值连接成一个字节流。消息解码后，解析器需要具有跳过无法识别的字段的功能，这样，可以向消息中加入新字段而不中断那些不识别它们的老程序。为此，消息中的每个键值对的键值实际上是两个值：.proto 文件中的字段数值和一个仅提供确定后面值长度信息的封装类型（wire type）。在大多数语言的实现中，这个键值被称为标记（TAG）。

可用的封装类型如下所示：

|类型|含义|用于|
|-|-|-|
|0|Varint|int32, int64, uint32, uint64, bool, enum|
|1|64-bit|fixed64, sfixed64, double|
|2|Length-delimited|string, bytes, embedded messages, packed repeated fields|
|3|start group| groups(已过时)|
|4|end group| groups(已过时)|
|5|32-bit|fixed32, sfixed32, float|

信息流中的每个键值是一个 varint，值为 `(field_number << 3) | (wire_type)`，换句话说，键值的最后三位存储了封装类型。

现在回到最开始的简单例子。我们现在知道流中的第一个数字一定是一个 varint 键值，这里是 0x08， 或者（移除 MSB）：

```
0001000
```

取出最后三位得到封装类型（0）之后右移三位得到字段数值（1）。因此现在知道了字段数值为 1 并且接下来的值是一个 varint。

利用上一部分介绍的有关 varint 解码的知识，可以解析出下面两个字节存储的值为 150。

```
0x96 0x01 = 10010110 00000001
          →  0000001  0010110
          → 10010110
          → 128 + 16 + 4 + 2 = 150 
```

## 更多的值类型

### 有符号整数

正如上一部分所介绍的那样，所有封装类型为 0 的 protocol buffer 类型都被编码为 varints。但是，在有符号整数类型（`sint32` 和 `sint64`）与标准整数类型（`int32` 和 `int64`）编码负数的时候有一个重要的区别。如果使用 `int32` 或 `int64` 作为负数的类型， varint 结果的长度总是 10 字节，实际上，它被视为一个非常大的无符号整数。如果你使用有符号整数类型，varint 结果会使用效率更高的 ZigZag 编码。

ZigZag 编码映射有符号整数到无符号整数，这样对于绝对值很小的数字（例如 -1）也可以编码为一个小的 varint。它通过一种往返与正数和负数间的 “之字形” 方式来达到这个目的，这样 -1 被编码为 1，1 被编码为 2，-2 被编码为 3，以此类推，如下表所示：

|原始值|编码值|
|-|-|
|0|0|
|-1|1|
|1|2|
|-2|3|
|2147483647|4294967294|
|-2147483648|4294967295|

换句话说，每个值 n 使用如下算法进行编码：

对于 `sint32`：

```
(n << 1) ^ (n >> 31)
```

对于 `sint64`：

```
(n << 1) ^ (n >> 63)
```

注意第二个移位操作`（n >> 31）`是算术移位。换句话说，移位的结果是一个比特位要么全为 0（当 n 为正数时）要么全为 1（当 n 为负数时）的数字。

当解析 `sint32` 或 `sint64` 时，会被解码回原始的有符号版本。

### 非 varint 数字

